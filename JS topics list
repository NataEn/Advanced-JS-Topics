1) coercion
2) threading- defines how many 
3) scope
4) hoisting-an imaginary process for understanding how the JS engine compiles JS code
5) array- an object that holds values (of any type) in numerically indexed positions instead of name/value pairs
6) polifill-essentially the specific code (or plugin) that would allow you to have some specific functionality that you expect 
in current or “modern” browsers, also work in other browsers that do not have the support for that functionality built in.
Polyfills are not part of the HTML5 standard and Polyfilling is not limited to Javascript.
7) let vs var
8) IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined.
9) asyncronouse programming
10) AJAX
11) inheritance rules (vs low level languages)
12) sla ? 
13) lazyload ?
14) CORS Protocol -read more at : https://medium.com/@mattlag/es6-modules-getting-started-gotchas-2ad154f38e2e
15) exports object for exporting total context of a js file
16) throw Error('some error')
17) stack in JS - all those functions that were called till the error occured
18) the event loop of the browser executing events in an async manner
19) continue vs break


Let Vs Var

let -introduced at 2015, block scope, not getting hoisted in the top of the scope?
var- functional scope (if declared inside a function it will maintain its value in the function and die at the end of it). 
Gets hoisted to the top of the function. 

example 1:

if (true){console.log(v);
console.log(l);
var v=2;
let l=3;
}
>> undefined (for v)
>>VM1183:1 Uncaught ReferenceError: Cannot access 'l' before initialization
    at <anonymous>:1:38
    
example 2:

a=()=>{
var v=2;
console.log(v);
}
a()
console.log(v)
>>2 (for the log inside the function)
>>Uncaught ReferenceError: v is not defined
    at <anonymous>:6:13 (for the log outside the function)

const vs let

const- has to be initialized in declaration. If value is a primitive its value cannot be changed.
let- doesn't have be initialized. Value can be changed even to a different type (primitive and not-primitive alike)  

example 1:

const c; 
c=1; 
console.log(c)
>> VM4610:1 Uncaught SyntaxError: Missing initializer in const declaration

const d=undefined;
console.log(d)
>>> VM599:1 Uncaught SyntaxError: Unexpected identifier (has to have a unique set of identifying chars: @,2,a etc ... undefined is not an option)

let l; (can also accept this:) let l=undefined
console.log(l)
>> undefined
l=1; 
console.log(l)
>>1

example 2: const holding an object can be modified

const c=[1,2,3]; 
c.push(4); 
console.log(c)
>> VM6256:1 (4) [1, 2, 3, 4]

but:
c=[1,2,3,4]
>> Uncaught TypeError: Assignment to constant variable.

null vs undefined
- both represent an ampty value.
null- set by the programmer
undefiened- set automatically to mutable variables if not initialized
typeof(undefiened)
>> 'undefined'
typeof(null)
>> 'object'

comparison operators == vs ===

== compairs the vaue
=== compaires the value and type 

example 1:
 console.log('1'==1)
 >> true
 how does this work? in order to compare, the engin will try to convert the type on the right side to the type on the left side (1-->'1') 
 console.log('1'===1)
 >> false
 here, the engin doesn't convert anything, just compaires the two values 

This, arrow functions and scopes

const profile={
firstName:'',
lastName:'',
setName: function(name){
    let splitName=function(n){
        let nameArray=n.split(' ')
        this.firstName=nameArray[0]
        this.lastName=nameArray[1]
        }
    splitName(name)
    }
}
profile.setName('Nina Lue') (here, the 'this' in splitName function, reffers to the window object, because the function's setName context is that of where it was invocked...)
console.log(firstName)
>>Nina
console.log(window.firstName)
>>Nina
console.log(profile.firstName)
>>  (-> '', returns an empty string)

example 2: changing splitName (inner function) to an arrow function

const profile={
firstName:'',
lastName:'',
setName: function(name){
    let splitName=(n)=>{
        let nameArray=n.split(' ')
        this.firstName=nameArray[0]
        this.lastName=nameArray[1]
        }
    splitName(name)
    }
}
profile.setName('Nina Lue') (here, the 'this' in splitName function, reffers to the window object, because the function's setName context is that of where it was invocked...)
console.log(firstName)
>>VM385:1 Uncaught ReferenceError: firstName is not defined ('this' reffers to the profile object)
console.log(profile.firstName)
>> Nina

example 3: changing setName (outer function) to an arrow function

const profile={
firstName:'',
lastName:'',
setName:(name)=>{
    let splitName=function(n){
        let nameArray=n.split(' ')
        this.firstName=nameArray[0]
        this.lastName=nameArray[1]
        }
    splitName(name)
    }
}
profile.setName('Nina Lue') (here, the 'this' in splitName function, reffers to the window object, because the function's setName context is that of where it was invocked...)
console.log(firstName)
>>Nina
console.log(profile.firstName)
>>  (-> '', returns an empty string)

example 4: changing both setName and splitName to an arrow function

const profile={
firstName:'',
lastName:'',
setName:(name)=>{
    let splitName=(n)=>{
        let nameArray=n.split(' ')
        this.firstName=nameArray[0]
        this.lastName=nameArray[1]
        }
    splitName(name)
    }
}
profile.setName('Nina Lue') 
console.log(firstName)
>>Nina
console.log(profile.firstName)
>>  (-> '', returns an empty string)


