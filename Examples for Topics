Let Vs Var

let -introduced at 2015, block scope, not getting hoisted in the top of the scope?
var- functional scope (if declared inside a function it will maintain its value in the function and die at the end of it). 
Gets hoisted to the top of the function. 

example 1:

if (true){console.log(v);
console.log(l);
var v=2;
let l=3;
}
>> undefined (for v)
>>VM1183:1 Uncaught ReferenceError: Cannot access 'l' before initialization
    at <anonymous>:1:38
    
example 2:

a=()=>{
var v=2;
console.log(v);
}
a()
console.log(v)
>>2 (for the log inside the function)
>>Uncaught ReferenceError: v is not defined
    at <anonymous>:6:13 (for the log outside the function)

const vs let

const- has to be initialized in declaration. If value is a primitive its value cannot be changed.
let- doesn't have be initialized. Value can be changed even to a different type (primitive and not-primitive alike)  

example 1:

const c; 
c=1; 
console.log(c)
>> VM4610:1 Uncaught SyntaxError: Missing initializer in const declaration

const d=undefined;
console.log(d)
>>> VM599:1 Uncaught SyntaxError: Unexpected identifier (has to have a unique set of identifying chars: @,2,a etc ... undefined is not an option)

let l; (can also accept this:) let l=undefined
console.log(l)
>> undefined
l=1; 
console.log(l)
>>1

example 2: const holding an object can be modified

const c=[1,2,3]; 
c.push(4); 
console.log(c)
>> VM6256:1 (4) [1, 2, 3, 4]

but:
c=[1,2,3,4]
>> Uncaught TypeError: Assignment to constant variable.

null vs undefined
- both represent an ampty value.
null- set by the programmer
undefiened- set automatically to mutable variables if not initialized
typeof(undefiened)
>> 'undefined'
typeof(null)
>> 'object'

Primitive Vs Objects--> passing by value vs passing by refference

example 1: passing by value --> primitive types
inside a block scope (let and const) or function scope (var), the values will be copied to the scope

var a=1
function changeA(a){
a=a+2
console.log(a)
}
changeA(a)
console.log(a)
>>3 (from inner console of changeA)
>>1 (from the window scope)

example 2: passing variable by refference
let obj={'moo':123}
function changeObj(a){
obj={'moo':456}
console.log(JSON.stringify(obj))
}
changeObj(obj)
console.log(obj)
>>{"moo":456}
>>VM572:3 {moo: 456}

comparison operators == vs ===

== compairs the vaue
=== compaires the value and type 

example 1:
 console.log('1'==1)
 >> true
 how does this work? in order to compare, the engin will try to convert the type on the right side to the type on the left side (1-->'1') 
 console.log('1'===1)
 >> false
 here, the engin doesn't convert anything, just compaires the two values 

This, arrow functions and scopes

const profile={
firstName:'',
lastName:'',
setName: function(name){
    let splitName=function(n){
        let nameArray=n.split(' ')
        this.firstName=nameArray[0]
        this.lastName=nameArray[1]
        }
    splitName(name)
    }
}
profile.setName('Nina Lue') (here, the 'this' in splitName function, reffers to the window object, because the function's setName context is that of where it was invocked...)
console.log(firstName)
>>Nina
console.log(window.firstName)
>>Nina
console.log(profile.firstName)
>>  (-> '', returns an empty string)

example 2: changing splitName (inner function) to an arrow function

const profile={
firstName:'',
lastName:'',
setName: function(name){
    let splitName=(n)=>{
        let nameArray=n.split(' ')
        this.firstName=nameArray[0]
        this.lastName=nameArray[1]
        }
    splitName(name)
    }
}
profile.setName('Nina Lue') (here, the 'this' in splitName function, reffers to the window object, because the function's setName context is that of where it was invocked...)
console.log(firstName)
>>VM385:1 Uncaught ReferenceError: firstName is not defined ('this' reffers to the profile object)
console.log(profile.firstName)
>> Nina

example 3: changing setName (outer function) to an arrow function

const profile={
firstName:'',
lastName:'',
setName:(name)=>{
    let splitName=function(n){
        let nameArray=n.split(' ')
        this.firstName=nameArray[0]
        this.lastName=nameArray[1]
        }
    splitName(name)
    }
}
profile.setName('Nina Lue') (here, the 'this' in splitName function, reffers to the window object, because the function's setName context is that of where it was invocked...)
console.log(firstName)
>>Nina
console.log(profile.firstName)
>>  (-> '', returns an empty string)

example 4: changing both setName and splitName to an arrow function

const profile={
firstName:'',
lastName:'',
setName:(name)=>{
    let splitName=(n)=>{
        let nameArray=n.split(' ')
        this.firstName=nameArray[0]
        this.lastName=nameArray[1]
        }
    splitName(name)
    }
}
profile.setName('Nina Lue') 
console.log(firstName)
>>Nina
console.log(profile.firstName)
>>  (-> '', returns an empty string)

getting all arguments sent to a function

function mySum(a+b){
return a+b
}
mySum(1,2)
mySum(1,2,3,4)
>>3
>>3 (the engin only takes the first 2 arguments)
But, to get all arguments sent to the function we can use the 'argumants' property of the function:
function mySum1(a,b){
let sum=0
for(let i=0;i<arguments.length;i++){ 
  sum+=arguments[i]
  }
  return sum
  } 
mySum1(1,2)
mySum1(1,2,3,4)
>>3
>>10
VERY IMPORTANT POINT: the 'argumants' is NOT an array, so array functions like splice, will not work on it
in order to work with the 'arguments' as an ararray use: Array.prototype.slice.call(argumants,1) --> this will replace: argumants.slice(1)

New 2015- rest operator: spread
function printOptions(...options){
console.log(options);
}
printOptions(1,2,3,4)
>>(4) [1, 2, 3, 4]

rest operator==spread operator
